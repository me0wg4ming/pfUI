v2.0.0 Changes

Added spell queuing, automatic retry on error, and quickcasting with lots of customization.

Some other key improvements over Namreeb's version:

    Using a buffer to avoid server rejections from casting too quickly (namreeb's uses 0 buffer). See 'Why do I need a buffer?' below for more info.
    Using high_resolution_clock instead of GetTickCount for faster timing on when to start casts
    Fix broken cast animations when casting spells back to back

Compatability with other addons

Queuing can cause issues with some addons that also manage spell casting. Quickheal/Healbot/Quiver do not work well with queuing. Check github issues for other potential incompatibilities. If someone rewrites these addons to use guids from superwow that would likely fix all issues.

Additionally, if you use pfui mouseover macros there is a timing issue that can occur causing it to target yourself instead of your mouseover target. If you have superwow and latest pfui issue is fixed.

Notgrid mouseover needs to be updated to take advantage of superwow the default version won't work well with queuing.

If you use healcomm can replace all instances of it in your addons with this version to work well with queuing https://github.com/MarcelineVQ/LunaUnitFrames/blob/TurtleWoW/libs/HealComm-1.0/HealComm-1.0.lua (requires superwow).

If all else fails can turn off queuing for a specific macro like so depending on the spell being cast:

/run SetCVar("NP_QueueCastTimeSpells", "0")
/run SetCVar("NP_QueueInstantSpells", "0")
/pfcast YOUR_SPELL
/run SetCVar("NP_QueueCastTimeSpells", "1")
/run SetCVar("NP_QueueInstantSpells", "1")

Installation

Grab the latest nampower.dll from https://gitea.com/avitasia/nampower/releases and place in the same directory as WoW.exe. You can also get the helper addon mentioned below and place that in Interface/Addons.

You will need launch the game with a launcher like Vanillafixes https://github.com/hannesmann/vanillafixes or Unitxp https://github.com/allfoxwy/UnitXP_SP3 to actually have the nampower dll get loaded.

If you would prefer to compile yourself you will need to get:

    boost 1.80 32 bit from https://www.boost.org/users/history/version_1_80_0.html
    hadesmem from https://github.com/namreeb/hadesmem

CMakeLists.txt is currently looking for boost at set(BOOST_INCLUDEDIR "C:/software/boost_1_80_0") and hadesmem at set(HADESMEM_ROOT "C:/software/hadesmem-v142-Debug-Win32"). Edit as needed.
Configuration
Configure with addon

There is a companion addon to make it easy to check/change the settings in game. You can download it here - nampowersettings.
Manual Configuration

The following CVars control the behavior of the spell queuing system:

You can access CVars in game with /run DEFAULT_CHAT_FRAME:AddMessage(GetCVar("CVarName"))
and set them with /run SetCVar("CVarName", "Value")

You can also just place them in your Config.wtf file in your WTF folder. If they are the default value they will not be written to the file. Example:

SET EnableMusic "0"
SET MasterSoundEffects "0"

SET NP_QuickcastTargetingSpells "1"
SET NP_SpellQueueWindowMs "1000"
SET NP_TargetingQueueWindowMs "1000"

    NP_QueueCastTimeSpells - Whether to enable spell queuing for spells with a cast time. 0 to disable, 1 to enable. Default is 1.

    NP_QueueInstantSpells - Whether to enable spell queuing for instant cast spells tied to gcd. 0 to disable, 1 to enable. Default is 1.

    NP_QueueChannelingSpells - Whether to enable channeling spell queuing as well as whether to allow any queuing during channels. 0 to disable, 1 to enable. Default is 1.

    NP_QueueTargetingSpells - Whether to enable terrain targeting spell queuing. 0 to disable, 1 to enable. Default is 1.

    NP_QueueOnSwingSpells - Whether to enable on swing spell queuing. 0 to disable, 1 to enable. Default is 0 (changed with 1.17.2 due to changes to on swing spells).

    NP_QueueSpellsOnCooldown - Whether to enable queuing for spells coming off cooldown. 0 to disable, 1 to enable. Default is 1.

    NP_InterruptChannelsOutsideQueueWindow - Whether to allow interrupting channels (the original client behavior) when trying to cast a spell outside the channeling queue window. Default is 0.

    NP_SpellQueueWindowMs - The window in ms before a cast finishes where the next will get queued. Default is 500.

    NP_OnSwingBufferCooldownMs - The cooldown time in ms after an on swing spell before you can queue on swing spells. Default is 500.

    NP_ChannelQueueWindowMs - The window in ms before a channel finishes where the next will get queued. Default is 1500.

    NP_TargetingQueueWindowMs - The window in ms before a terrain targeting spell finishes where the next will get queued. Default is 500.

    NP_CooldownQueueWindowMs - The window in ms of remaining cooldown where a spell will get queued instead of failing with 'Spell not Ready Yet'. Default is 250.

    NP_MinBufferTimeMs - The minimum buffer delay in ms added to each cast (covered more below). The dynamic buffer adjustments will not go below this value. Default is 55.

    NP_NonGcdBufferTimeMs - The buffer delay in ms added AFTER each cast that is not tied to the gcd. Default is 100.

    NP_MaxBufferIncreaseMs - The maximum amount of time in ms to increase the buffer by when the server rejects a cast. This prevents getting too long of a buffer if you happen to get a ton of rejections in a row. Default is 30.

    NP_RetryServerRejectedSpells - Whether to retry spells that are rejected by the server for these reasons: SPELL_FAILED_ITEM_NOT_READY, SPELL_FAILED_NOT_READY, SPELL_FAILED_SPELL_IN_PROGRESS. 0 to disable, 1 to enable. Default is 1.

    NP_QuickcastTargetingSpells - Whether to enable quick casting for ALL spells with terrain targeting. This will cause the spell to instantly cast on your cursor without waiting for you to confirm the targeting circle. Queuing targeting spells will use quickcasting regardless of this value. 0 to disable, 1 to enable. Default is 0.

    NP_QuickcastOnDoubleCast - Whether to allow casting targeting spells by attempting to cast them twice, as opposed to the default client behavior which cancels the targeting indicator on double cast. This provides an alternative way to quickcast targeting spells without enabling it for all targeting spells. 0 to disable, 1 to enable. Default is 0.

    NP_ReplaceMatchingNonGcdCategory - Whether to replace any queued non gcd spell when a new non gcd spell with the same StartRecoveryCategory is cast (more explanation below). 0 to disable, 1 to enable. Default is 0.

    NP_OptimizeBufferUsingPacketTimings - Whether to attempt to optimize your buffer using your latency and server packet timings (more explanation below). 0 to disable, 1 to enable. Default is 0.

    NP_PreventRightClickTargetChange - Whether to prevent right-clicking from changing your current target when in combat. If you don't have a target right click will still change your target even with this on. This is mainly to prevent accidentally changing targets in combat when trying to adjust your camera. 0 to disable, 1 to enable. Default is 0.

    NP_PreventRightClickPvPAttack - Whether to prevent right-clicking on PvP flagged players to avoid accidental PvP attacks. 0 to disable, 1 to enable. Default is 0.

    NP_DoubleCastToEndChannelEarly - Whether to allow double casting a spell within 350ms to end channeling on the next tick. Takes into account your ChannelLatencyReductionPercentage. 0 to disable, 1 to enable. Default is 0.

    NP_SpamProtectionEnabled - Whether to enable spam protection functionality that blocks spamming spells while waiting for the server to respond to your initial cast due to issues spamming can cause. 0 to disable, 1 to enable. Default is 1.

    NP_PreventMountingWhenBuffCapped - Whether to prevent mounting when you have 32 buffs (buff capped) and are not already mounted. This prevents the issue where you mount but cannot dismount because the mount aura fails to apply due to the buff cap. When blocked, displays an error message. 0 to disable, 1 to enable. Default is 1.

    NP_EnableAuraCastEvents - Whether to enable AURA_CAST_ON_SELF and AURA_CAST_ON_OTHER events. 0 to disable, 1 to enable. Default is 0.

    NP_ChannelLatencyReductionPercentage - The percentage of your latency to subtract from the end of a channel duration to optimize cast time while hopefully not losing any ticks (more explanation below). Default is 75.

    NP_NameplateDistance - The distance in yards to display nameplates. Defaults to whatever was set by the game or vanilla tweaks.

Existing Lua Changes
Improved flexibility on spellbook Lua functions

These built-in Lua spell APIs now accept any of the following as their first argument: 1) spell slot (original behavior), 2) spell name, or 3) spellId:number.

Name and spellId lookups are cached internally and validated against current spellbook contents before reuse so you don't have to worry about performance implications or issues after respec'ing.

See examples below for differences in how BOOKTYPE works.

Functions: GetSpellTexture, GetSpellName, GetSpellCooldown, GetSpellAutocast, ToggleSpellAutocast, PickupSpell, CastSpell, IsCurrentCast, IsSpellPassive.

Examples:

/run print(GetSpellTexture(1, "spell")) -- booktype required
/run print(GetSpellTexture("spellId:25978")) -- defaults to BOOKTYPE_SPELL
/run print(GetSpellTexture("spellId:6268", "pet")) -- "pet" needed for pet spells
/run print(GetSpellTexture("Fireball")) -- name search

Custom Lua Functions

For complete documentation of all custom Lua functions added by Nampower, see SCRIPTS.md.

This includes functions for:

    Spell/item/unit information (GetItemStats, GetSpellRec, GetUnitData, etc.)
    Spell casting and queuing (QueueSpellByName, QueueScript, etc.)
    Cast information (GetCastInfo, GetCurrentCastingInfo)
    Cooldown tracking (GetSpellIdCooldown, GetItemIdCooldown), including item metadata on cooldown detail tables
    Inventory helpers (GetTrinketCooldown, GetTrinkets)
    Spell lookups and utilities

Cooldown detail tables now also expose itemId, itemHasActiveSpell, and itemActiveSpellId alongside the existing per-category timing data.

Use GetTrinkets([copy]) to enumerate equipped trinkets and bagged trinkets (backpack/bags 1-4) with itemId, trinketName, texture, itemLevel, bagIndex (nil when equipped), and 1-based slotIndex. It reuses cached tables by default; pass 1 (or any truthy value) to force a fresh copy.
Custom Events

For complete documentation of all custom events added by Nampower, see EVENTS.md.

Available events:

    SPELL_QUEUE_EVENT - Fires when spells are queued or dequeued
    SPELL_CAST_EVENT - Fires when you cast a spell with additional information
    SPELL_DAMAGE_EVENT_SELF and SPELL_DAMAGE_EVENT_OTHER - Combat damage events
    Buff/Debuff Events (BUFF_ADDED_SELF, BUFF_REMOVED_SELF, etc.)
    AURA_CAST_ON_SELF and AURA_CAST_ON_OTHER - Aura application events (fires once per aura effect; "Self" fires when the aura lands on the active player, including self-cast with no explicit target; includes aura metadata + amplitude/misc + aura cap bitfield for buff/debuff slots). Some auras don’t have spell effects and won’t trigger this; use BUFF/DEBUFF gains for those. Set NP_EnableAuraCastEvents=1 to enable.
    UNIT_DIED - Fires when a unit dies

Bug Reporting

If you encounter any bugs please report them in the issues tab. Please include the nampower_debug.txt file in the same directory as your WoW.exe to help me diagnose the issue. If you are able to reproduce the bug please include the steps to reproduce it. In a future version once bugs are ironed out I'll make logging optional.
FAQ & Additional Info
How does queuing work?

Trying to cast a spell within the appropriate window before your current spell finishes will queue your new spell.
The spell will be cast as soon as possible after the current spell finishes.

There are separate configurable queue windows for:

    Normal spells
    On swing spells (the window functions as a cooldown instead where you cannot immediately double queue on swing spells so that I don't have to track swing timers)
    Channeling spells
    Spells with terrain targeting

There are 3 separate queues for the following types of spells: GCD(max size:1), non GCD(max size:6), and on-hit(max size:1).

Additionally the queuing system will ignore spells with any of the following attributes/effects to avoid issues with tradeskills/enchants/other out of combat activities:

    SpellAttributes::SPELL_ATTR_TRADESPELL
    SpellEffects::SPELL_EFFECT_TRADE_SKILL
    SpellEffects::SPELL_EFFECT_ENCHANT_ITEM
    SpellEffects::SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
    SpellEffects::SPELL_EFFECT_CREATE_ITEM
    SpellEffects::SPELL_EFFECT_OPEN_LOCK
    SpellEffects::SPELL_EFFECT_OPEN_LOCK_ITEM

Why do I need a buffer?

From my own testing it seems that a buffer is required on spells to avoid "This ability isn't ready yet"/"Another action in progress" errors.
By that I mean that if you cast a 1.5 second cast time spell every 1.5 seconds without your ping changing you will occasionally get errors from the server and your cast will get rejected. If you have 150ms+ ping this can be very punishing.

I believe this is related to the server tick during which incoming spells are processed. There is logic to subtract the server processing time from your gcd in vmangos but other servers do not appear to be doing this.

To compensate for what seems to be a 50ms server tick the default buffer in nampower.cfg is 55ms. If you are close to the server you can experiment with lowering this value. You will occasionally get errors but if they are infrequent enough for you the time saved will be worth it.

Non gcd spells also seem to be affected by this. I suspect that only one spell can be processed per server tick.
This means that if you try to cast 2 non gcd spells in the same server tick only one will be processed.
To avoid this happening there is NP_NonGcdBufferTimeMs which is added after each non gcd spell. There might be more to it than this as using the normal buffer of 55ms was still resulting in skipped casts for me. I found 100ms to be a safe value.
GCD Spells

Only one gcd spell can be queued at a time. Pressing a new gcd spell will replace any existing queued gcd spell.

As of 5/13/2025 the server tick is now subtracted from the gcd timer so a buffer is no longer required for spells with a cast time at least ~50ms less than their gcd :)
Non GCD Spells

Non gcd spells have special handling. You can queue up to 6 non gcd spells, and they will execute in the order queued with NP_NonGcdBufferTimeMs delay after each of them to help avoid server rejection.
The non gcd queue always has priority over queued normal spells.
You can only queue a given spellId once in the non gcd queue, any subsequent attempts will just replace the existing entry in the queue.

NP_ReplaceMatchingNonGcdCategory will cause non gcd spells with the same non zero StartRecoveryCategory to replace each other in the queue.
The vast majority of spells not on the gcd have category '0' so it ignores them to avoid causing issues.
One notable exception is shaman totems that were changed to have separate categories according to their elements.

This can be useful if you want to change your mind about the non gcd spell you have queued. For example, if you queue a mana potion and decide you want to use LIP instead last minute.
On hit Spells

Only one on hit spell can be queued at a time. Pressing a new on hit spell will replace any existing queued on hit spell.
On hit spells have no effect on the gcd or non gcd queues as they are handled entirely separately and are resolved by your auto attack.
Channeling Spells

Channeling spells function differently than other spells in that the channel in the client actually begins when you receive the CHANNEL_START packet from the server. This means the client channel is happening 1/2 your latency after the server channel and that server tick delay is already included in the cast, whereas regular spells are the other way around (the client is ahead of the server).

From my testing it seems that you can usually subtract your full latency from the end of the channel duration without losing any ticks. Since your latency can vary it is safer to do a percentage of your latency instead to minimize the chance of having a tick cut off. This is controlled by the cvar NP_ChannelLatencyReductionPercentage which defaults to 75.

Channeling spells can be interrupted outside the channel queue window by casting any spell if NP_InterruptChannelsOutsideQueueWindow is set to 1. During the channel queue window you cannot interrupt the channel unless you turn off NP_QueueChannelingSpells. You can always move to interrupt a channel at any time.
Spells on Cooldown

If using NP_QueueSpellsOnCooldown when you attempt to cast a spell that has a remaining cooldown of less than NP_CooldownQueueWindowMs it will be queued instead of failing with 'Spell not Ready Yet'. There is a separate queue of size 1 for normal spells and non gcd spells. If something is in either of these cooldown queues and you try to cast a spell that is not on cooldown it will be cast immediately and clear the appropriate cooldown queue.

For example, if Fire Blast is on cooldown and I queue it and then try to cast Fireball it will cast Fireball immediately and Fire Blast will not get automatically cast anymore.

This currently doesn't work for item cooldowns as they work differently, will add in the future.
NP_OptimizeBufferUsingPacketTimings

This feature will attempt to optimize your buffer on individual casts using your latency and server packet timings.
After you begin to cast a spell you will get a cast result packet back from the server letting you know if the cast was successful. The time between when you send your start cast packet and when you receive the cast result packet consists of:

    The time it takes for your packet to reach the server
    The time it takes for the server to process the packet (see Why do I need a buffer?)
    The time it takes for the server to send the result packet back to you
    Other delays I'm not sure about like the time it takes for the client to process packets from the server due to being single threaded

If we take this 'Spell Response Time' and subtract your regular latency from it, we should be able to get a rough idea of the time it took for the server to process the cast. If that time was less than your current default buffer we can use that time as the new buffer for the next cast only. In theory if it is more than your current buffer we should also use it, but in practice it seems to regularly be way larger than expected and using the default buffer doesn't result in an error.

Due to this delay varying wildly in testing I'm unsure how reliable this technique is. It needs more testing and a better understanding of all the factors introducing delay. It is disabled by default for now.

# DBC Field Names

Related structs live in `nampower/game.hpp` (notably `SpellRec` and `ItemStats_C`).

## ItemStats_C Fields (alphabetical)
- `allowableClass`
- `allowableRace`
- `ammoType`
- `area`
- `bagFamily`
- `block`
- `bonding`
- `buyPrice`
- `class`
- `containerSlots`
- `delay`
- `displayInfoID`
- `duration`
- `flags`
- `inventoryType`
- `itemLevel`
- `itemSet`
- `languageID`
- `lockID`
- `map`
- `material`
- `maxCount`
- `maxDurability`
- `pageMaterial`
- `pageText`
- `quality`
- `randomProperty`
- `rangedModRange`
- `requiredCityRank`
- `requiredHonorRank`
- `requiredLevel`
- `requiredRep`
- `requiredRepRank`
- `requiredSkill`
- `requiredSkillRank`
- `requiredSpell`
- `sellPrice`
- `sheatheType`
- `stackable`
- `startQuestID`
- `subclass`

### ItemStats_C Array Fields (alphabetical)
- `bonusAmount`
- `bonusStat`
- `damageType`
- `maxDamage`
- `minDamage`
- `resistances`
- `spellCategory`
- `spellCategoryCooldown`
- `spellCharges`
- `spellCooldown`
- `spellID`
- `spellTrigger`

## SpellRec Fields (alphabetical)
- `activeIconID`
- `attributes`
- `attributesEx`
- `attributesEx2`
- `attributesEx3`
- `attributesEx4`
- `auraInterruptFlags`
- `baseLevel`
- `castUI`
- `category`
- `categoryRecoveryTime`
- `casterAuraState`
- `castingTimeIndex`
- `channelInterruptFlags`
- `dispel`
- `dmgClass`
- `durationIndex`
- `equippedItemClass`
- `equippedItemInventoryTypeMask`
- `equippedItemSubClassMask`
- `id`
- `interruptFlags`
- `manaCost`
- `manaCostPercentage`
- `manaCostPerlevel`
- `manaPerSecond`
- `manaPerSecondPerLevel`
- `maxAffectedTargets`
- `maxLevel`
- `maxTargetLevel`
- `mechanic`
- `minFactionId`
- `minReputation`
- `modalNextSpell`
- `powerType`
- `preventionType`
- `procChance`
- `procCharges`
- `procFlags`
- `rangeIndex`
- `recoveryTime`
- `requiredAuraVision`
- `school`
- `spellFamilyFlags`
- `spellFamilyName`
- `spellIconID`
- `spellLevel`
- `spellPriority`
- `spellVisual`
- `spellVisual2`
- `stackAmount`
- `stances`
- `stancesNot`
- `startRecoveryCategory`
- `startRecoveryTime`
- `targetAuraState`
- `targetCreatureType`
- `targets`

### SpellRec Array Fields (alphabetical)
- `dmgMultiplier`
- `effect`
- `effectAmplitude`
- `effectApplyAuraName`
- `effectBaseDice`
- `effectBasePoints`
- `effectChainTarget`
- `effectDicePerLevel`
- `effectDieSides`
- `effectImplicitTargetA`
- `effectImplicitTargetB`
- `effectItemType`
- `effectMechanic`
- `effectMiscValue`
- `effectMultipleValue`
- `effectPointsPerComboPoint`
- `effectRadiusIndex`
- `effectRealPointsPerLevel`
- `effectTriggerSpell`
- `reagent`
- `reagentCount`
- `totem`

# Nampower Custom Events

This document describes all custom events added by Nampower that you can register and listen to in your addons.

For custom Lua functions, see [SCRIPTS.md](SCRIPTS.md). For general usage information, see [README.md](README.md).

## Table of Contents
- [SPELL_QUEUE_EVENT](#spell_queue_event)
- [SPELL_CAST_EVENT](#spell_cast_event)
- [SPELL_DAMAGE_EVENT_SELF and SPELL_DAMAGE_EVENT_OTHER](#spell_damage_event_self-and-spell_damage_event_other)
- [Buff/Debuff Events](#buffdebuff-events)
- [AURA_CAST_ON_SELF and AURA_CAST_ON_OTHER](#aura_cast_on_self-and-aura_cast_on_other)
- [UNIT_DIED](#unit_died)

---

## Custom Events

### SPELL_QUEUE_EVENT
I've added a new event you can register in game to get updates when spells are added and popped from the queue.

The event is `SPELL_QUEUE_EVENT` and has 2 parameters:
1.  int eventCode - see below
2.  int spellId

Possible Event codes:
```
 ON_SWING_QUEUED = 0
 ON_SWING_QUEUE_POPPED = 1
 NORMAL_QUEUED = 2
 NORMAL_QUEUE_POPPED = 3
 NON_GCD_QUEUED = 4
 NON_GCD_QUEUE_POPPED = 5
```

Example from NampowerSettings:
```
local ON_SWING_QUEUED = 0
local ON_SWING_QUEUE_POPPED = 1
local NORMAL_QUEUED = 2
local NORMAL_QUEUE_POPPED = 3
local NON_GCD_QUEUED = 4
local NON_GCD_QUEUE_POPPED = 5

local function spellQueueEvent(eventCode, spellId)
	if eventCode == NORMAL_QUEUED or eventCode == NON_GCD_QUEUED then
		local _, _, texture = SpellInfo(spellId) -- superwow function
		Nampower.queued_spell.texture:SetTexture(texture)
		Nampower.queued_spell:Show()
	elseif eventCode == NORMAL_QUEUE_POPPED or eventCode == NON_GCD_QUEUE_POPPED then
		Nampower.queued_spell:Hide()
	end
end

NampowerSettings:RegisterEvent("SPELL_QUEUE_EVENT", spellQueueEvent)
```

### SPELL_CAST_EVENT
Event you can register in game to get updates when you cast spells with some additional information.  This will only fire for spells you (and certain pets) initiated.

The event is `SPELL_CAST_EVENT` and has 5 parameters:
1.  int success - 1 if cast succeeded, 0 if failed
2.  int spellId
3.  int castType - see below
4.  string targetGuid - guid string like "0xF5300000000000A5"
5.  int itemId - the id of the item that triggered the spell, 0 if it wasn't triggered by an item

Possible Cast Types:
```
NORMAL=1
NON_GCD=2
ON_SWING=3
CHANNEL=4
TARGETING=5 (targeting is the term I used for spells with terrain targeting)
TARGETING_NON_GCD=6
```

targetGuid will be "0x000000000" unless an explicit target is specified which currently only happens in 2 circumstances:
- It was specified as the 2nd param of CastSpellByName (added by superwow)
- Mouseover casts that use SpellTargetUnit to specify a target

Example (uses ace RegisterEvent):
```
Cursive:RegisterEvent("SPELL_CAST_EVENT", function(success, spellId, castType, targetGuid, itemId)
	print(success)
	print(spellId)
	print(castType)
	print(targetGuid)
	print(itemId)
end);
```

### SPELL_DAMAGE_EVENT_SELF and SPELL_DAMAGE_EVENT_OTHER
New events you can register in game to get updates whenever spell damage occurs. SPELL_DAMAGE_EVENT_SELF will only trigger for damage you deal, while SPELL_DAMAGE_EVENT_OTHER will only trigger for damage dealt by others.

Both of these events have the following parameters:
1.  string targetGuid - guid string like "0xF5300000000000A5"
2.  string casterGuid - guid string like "0xF5300000000000A5"
3.  int spellId
4.  int amount - the amount of damage dealt.  If the 4th value in effectAuraStr is 89 (SPELL_AURA_PERIODIC_DAMAGE_PERCENT) I believe this is the percentage of health lost.
5.  string mitigationStr - comma separated string containing "aborb,block,resist" amounts
6.  int hitInfo - see below but generally 0 unless the spell was a crit in which case it will be 2
7.  int spellSchool - the damage school of the spell, see below
8.  string effectAuraStr - comma separated string containing the three spell effect numbers and the aura type (usually means a Dot but not all Dots will have an aura type) if applicable.  So "effect1,effect2,effect3,auraType"

Spell hit info enum: https://github.com/vmangos/core/blob/94f05231d4f1b160468744d4caa398cf8b337c48/src/game/Spells/SpellDefines.h#L109

Spell school enum:  https://github.com/vmangos/core/blob/94f05231d4f1b160468744d4caa398cf8b337c48/src/game/Spells/SpellDefines.h#L641

Spell effect enum: https://github.com/vmangos/core/blob/94f05231d4f1b160468744d4caa398cf8b337c48/src/game/Spells/SpellDefines.h#L142

Aura type enum: https://github.com/vmangos/core/blob/94f05231d4f1b160468744d4caa398cf8b337c48/src/game/Spells/SpellAuraDefines.h#L43

Example (uses ace RegisterEvent):
```
Cursive:RegisterEvent("SPELL_DAMAGE_EVENT_SELF",
    function(targetGuidStr,
             casterGuidStr,
             spellId,
             amount,
             mitigationStr,
             hitInfo,
             spellSchool,
             effectAuraStr)
        print(targetGuidStr .. " " .. casterGuidStr .. " " .. tostring(spellId) .. " " .. tostring(amount) .. " " .. tostring(spellSchool) .. " " .. mitigationStr .. " " .. hitInfo .. " " .. effectAuraStr)
    end);
```

### Buff/Debuff Events
New events fire whenever a buff or debuff is added or removed on you or any other unit that the client tracks.

Events:
```
BUFF_ADDED_SELF
BUFF_REMOVED_SELF
BUFF_ADDED_OTHER
BUFF_REMOVED_OTHER
DEBUFF_ADDED_SELF
DEBUFF_REMOVED_SELF
DEBUFF_ADDED_OTHER
DEBUFF_REMOVED_OTHER
```

All eight events pass the same parameters:
1.  string guid - unit guid like "0xF5300000000000A5"
2.  int slot - 1-based Lua slot index for the buff/debuff (skips empty slots to match UnitBuff/UnitDebuff ordering)
3.  int spellId
4.  int stackCount - current stack count for the aura (1 for a new aura; 0 when fully removed)
5.  int auraLevel - caster level for the aura from UnitFields.auraLevels (uint8 per slot, 48 entries)

Buff stack gains also fire the appropriate *_ADDED_* events.

Example:
```
local function onAuraEvent(eventName, guid, slot, spellId, stacks, auraLevel)
    DEFAULT_CHAT_FRAME:AddMessage(string.format("[%s] %s slot=%d spell=%d stacks=%d level=%d", eventName, guid, slot, spellId, stacks, auraLevel))
end

for _, eventName in ipairs({"BUFF_ADDED_SELF", "BUFF_REMOVED_SELF", "DEBUFF_ADDED_OTHER", "DEBUFF_REMOVED_OTHER"}) do
    frame:RegisterEvent(eventName, function(...) onAuraEvent(eventName, ...) end)
end
```

### AURA_CAST_ON_SELF and AURA_CAST_ON_OTHER
Fire when a spell cast applies an aura. "Self" covers casts that land on the active player (including cases where the active player is the caster with no explicit target); "Other" covers all other targets.

These events are gated behind the `NP_EnableAuraCastEvents` CVar (default 0). Set it to `1` to enable.
**Note:** some auras do not have spell effects and won’t trigger these events; the BUFF/DEBUFF gain events are the only way to track those.

These events are primarily intended for basic tracking of aura applications when buff/debuff caps prevent normal GAINS events from firing.

Parameters:
1.  int spellId
2.  string casterGuid - caster guid like "0xF5300000000000A5"
3.  string targetGuid - target guid like "0xF5300000000000A5"
4.  int effect - aura-applying effect id (event fires once for each qualifying effect in the spell)
5.  int effectAuraName - corresponding entry from EffectApplyAuraName
6.  int effectAmplitude - EffectAmplitude entry for the selected aura effect
7.  int effectMiscValue - EffectMiscValue entry for the selected aura effect
8.  int durationMs - spell duration in milliseconds (includes client modifiers if you are the caster)
9.  int auraCapStatus - bitfield: 1 = buff bar full, 2 = debuff bar full (3 means both)

### UNIT_DIED
Fires when a unit death is recorded in the combat log.

Parameters:
1.  string guid - guid of the unit that died

Example:
```
frame:RegisterEvent("UNIT_DIED", function(guid)
    DEFAULT_CHAT_FRAME:AddMessage("Unit died: " .. guid)
end)
```

# Nampower Custom Lua Functions

This document describes all custom Lua functions and events added by Nampower.

For installation, configuration, and general usage information, see the main [README.md](README.md).

## Table of Contents
- [Performance Optimization - Table References](#performance-optimization---table-references)
- [Custom Lua Functions](#custom-lua-functions)
  - [Spell/Item/Unit Information](#spellitemunit-information)
    - [GetItemStats](#getitemstatsitemid-copy)
    - [GetItemStatsField](#getitemstatsfielditemid-fieldname-copy)
    - [FindPlayerItemSlot](#findplayeritemslotitemid-or-itemname)
    - [UseItemIdOrName](#useitemidornameitemidorname-target)
    - [GetEquippedItems](#getequippeditemsunittoken)
    - [GetEquippedItem](#getequippeditemunittoken-slot)
    - [GetBagItems](#getbagitems)
    - [GetBagItem](#getbagitembagindex-slot)
    - [GetSpellRec](#getspellrecspellid-copy)
    - [GetSpellRecField](#getspellrecfieldspellid-fieldname-copy)
    - [GetSpellModifiers](#getspellmodifiersspellid-modifiertype)
    - [GetUnitData](#getunitdataunittoken-copy)
    - [GetUnitField](#getunitfieldunittoken-fieldname-copy)
    - [GetSpellIdForName](#getspellidfornamenspellname)
    - [GetSpellNameAndRankForId](#getspellnameandrankforidid)
    - [GetSpellSlotTypeIdForName](#getspellslottypeidfornamenspellname)
    - [GetNampowerVersion](#getnampowerversion)
    - [GetItemLevel](#getitemlevelitemid)
  - [Spell Casting and Queuing](#spell-casting-and-queuing)
    - [QueueSpellByName](#queuespellbynamespellname)
    - [CastSpellByNameNoQueue](#castspellbynamenoqueuespellname)
    - [QueueScript](#queuescriptscript-priority)
    - [IsSpellInRange](#isspellinrangespellname-target-or-isspellinrangespellid-target)
    - [IsSpellUsable](#isspellusablespellname-or-isspellusablespellid)
    - [ChannelStopCastingNextTick](#channelstopcastingnexttick)
  - [Cast Information](#cast-information)
    - [GetCurrentCastingInfo](#getcurrentcastinginfo)
    - [GetCastInfo](#getcastinfo)
  - [Cooldown Information](#cooldown-information)
    - [GetSpellIdCooldown](#getspellidcooldownspellid)
    - [GetItemIdCooldown](#getitemidcooldownitemid)
    - [GetTrinkets](#gettrinketscopy)
    - [GetTrinketCooldown](#gettrinketcooldownslotitemidorname)
    - [UseTrinket](#usetrinketslotitemidorname-target)
  - [Utility Functions](#utility-functions)
    - [DisenchantAll](#disenchantallitemidorname-or-disenchantallquality)
---

## Performance Optimization - Table References

Nampower functions that return tables use **reusable table references** to reduce memory allocations and improve performance. This means the same table object is reused across multiple function calls, with its contents updated each time.

### Functions Using Reusable Table References

The following functions use reusable table references:

- **`GetCastInfo()`** - Returns cast information table
- **`GetEquippedItems([unitToken])`** - Returns equipped items table
- **`GetBagItems()`** - Returns bag items table
- **`GetBagItem(bagIndex, slot)`** - Returns item info table
- **`GetEquippedItem(unitToken, slot)`** - Returns item info table
- **`GetSpellIdCooldown(spellId)`** - Returns cooldown detail table
- **`GetItemIdCooldown(itemId)`** - Returns cooldown detail table
-
- **`GetItemStats(itemId, [copy])`** - Returns item stats table
- **`GetUnitData(unitToken, [copy])`** - Returns unit data table
- **`GetSpellRec(spellId, [copy])`** - Returns spell record table
- **`GetItemStatsField(itemId, fieldName, [copy])`** - Returns individual item field value
- **`GetUnitField(unitToken, fieldName, [copy])`** - Returns individual unit field value
- **`GetSpellRecField(spellId, fieldName, [copy])`** - Returns individual spell field value
- **`GetTrinkets([copy])`** - Returns trinket list table

**Important:** When using these functions without the `copy` parameter, **immediately copy or extract** any values you need to store for later use. Do not store references to the returned tables themselves. Alternatively, pass `1` as the `copy` parameter to get an independent table that is safe to store.

**Note:** Functions like `GetItemStats`, `GetUnitData`, and `GetSpellRec` also use reusable references for their nested array fields (e.g., `bonusStat`, `auras`, `EffectImplicitTargetA`). Each nested array field name has its own dedicated reference that is reused across calls.

```lua
-- ✓ SAFE - Extract values immediately
local castInfo = GetCastInfo()
if castInfo then
    local spellId = castInfo.spellId
    local castEnd = castInfo.castEndS
    -- Use spellId and castEnd later
end

-- ✓ SAFE - Extract nested array values immediately
local itemStats = GetItemStats(19019)
if itemStats then
    local bonusStats = {}
    for i = 1, #itemStats.bonusStat do
        bonusStats[i] = itemStats.bonusStat[i]
    end
    -- Now bonusStats is a safe independent copy
end

-- ✗ UNSAFE - Storing table references from the same function
local cast1 = GetCastInfo()  -- Gets table reference
-- ... later ...
local cast2 = GetCastInfo()  -- Gets SAME table reference with new data
-- cast1 and cast2 both point to the same table with cast2's data!

-- ✗ UNSAFE - Storing nested array references
local item1 = GetItemStats(19019)
local item1BonusStats = item1.bonusStat  -- Stores reference to nested array
local item2 = GetItemStats(22589)
-- item1BonusStats was overwritten! The "bonusStat" nested array reference is reused

-- ✓ SAFE - Using copy parameter for nested arrays
local item1 = GetItemStats(19019, 1)  -- Pass 1 to get independent copy
local item1BonusStats = item1.bonusStat  -- Safe to store, it's an independent copy
local item2 = GetItemStats(22589, 1)  -- Another independent copy
-- Both item1BonusStats and item2.bonusStat are independent tables
```

**Important for array field functions:** Each field name gets its own dedicated table reference, but the table is still reused across calls with the same field name. **Always extract values immediately - never store the table reference itself.** Alternatively, pass `1` as the `copy` parameter to get an independent table copy:

```lua
-- ✓ SAFE - Extract array values immediately
local bonusStats = {}
local tempTable = GetItemStatsField(itemId, "bonusStat")
for i = 1, #tempTable do
    bonusStats[i] = tempTable[i]
end
-- Now bonusStats is a safe independent copy

-- ✓ EASIER - Use copy parameter to get independent table
local bonusStats = GetItemStatsField(itemId, "bonusStat", 1)
-- Safe to store, no manual copying needed!

-- ✗ UNSAFE - Storing table references (even with different field names)
local bonusStats = GetItemStatsField(itemId, "bonusStat")
local bonusAmounts = GetItemStatsField(itemId, "bonusAmount")
-- Later...
local newBonusStats = GetItemStatsField(otherItemId, "bonusStat")
-- bonusStats was overwritten! The "bonusStat" reference is reused across calls

-- ✗ ALSO UNSAFE - Same field name, multiple calls
local item1Stats = GetItemStatsField(19019, "bonusStat")
local item2Stats = GetItemStatsField(22589, "bonusStat")
-- item1Stats was immediately overwritten by the second call!
```

---

### Custom Lua Functions

### Spell/Item/Unit information

#### GetItemStats(itemId, [copy])
Returns a Lua table reference containing all fields for the item's `ItemStats` record (including localized `displayName` and `description`). Returns nil if the item cannot be found or loaded.

**Optional parameter:** Pass `1` for `copy` to get an independent table copy instead of a reusable reference.

Full field name lists are in [`DBC_FIELDS.md`](DBC_FIELDS.md).

#### GetItemStatsField(itemId, fieldName, [copy])
Fast lookup for a single field on an item. Returns the requested field value; returns nil if the item is not found; raises a Lua error if the field name is invalid.

**Optional parameter:** Pass `1` for `copy` to get an independent table copy (for array fields only).

Full field name lists are in [`DBC_FIELDS.md`](DBC_FIELDS.md).

**Examples:**
```lua
-- Get item name
local name = GetItemStatsField(19019, "displayName")
print(name) -- "Thunderfury, Blessed Blade of the Windseeker"

-- Get item level
local ilvl = GetItemStatsField(22589, "itemLevel")
print("Atiesh item level: " .. ilvl) -- 90

-- Get item quality (0=Poor, 1=Common, 2=Uncommon, 3=Rare, 4=Epic, 5=Legendary)
local quality = GetItemStatsField(19019, "quality")
print("Quality: " .. quality) -- 5 (Legendary)

-- Get item delay (weapon speed in milliseconds)
local delay = GetItemStatsField(19019, "delay")
print("Weapon speed: " .. (delay / 1000) .. " seconds") -- 1.9 seconds
```

#### FindPlayerItemSlot(itemId or itemName)
Searches the player's inventory for an item by ID or name and returns its location.

**Parameters:**
- `itemId` (number): The item ID to search for, OR
- `itemName` (string): The item name to search for (case-insensitive)

**Returns:**
- 1st param (number or nil): Bag index where the item was found
  - `nil` = Equipped item (check 2nd param for equipment slot 0-18)
  - `0` = Inventory pack
  - `1-4` = Regular bags
  - `-1` = Bank item slots
  - `5-9` = Bank bags
  - `-2` = Keyring
- 2nd param (number): Slot number within the bag (or equipment slot if 1st param is nil)
  - For equipped items: 0-18 (equipment slots are 0-indexed)
  - For bag 0, -1, -2: Returns **relative slot position** (1-indexed, 0-based within bag + 1)
    - Bag 0: slots 1-16 (corresponding to absolute slots 23-38)
    - Bag -1: slots 1-24 (corresponding to absolute bank slots 39-62)
    - Bag -2: slots 1-16 (corresponding to absolute keyring slots 81-96)
  - For regular bags (1-4) and bank bags (5-9): Returns 1-indexed slot within the bag
- Returns `nil,nil` if the item is not found

**Examples:**
```lua
-- Find Thunderfury in player inventory
local bag, slot = FindPlayerItemSlot(19019)
if bag then
    print("Found in bag " .. bag .. " slot " .. slot)
    if bag == -1 or (bag >= 5 and bag <= 9) then
        print("Item is in bank")
    end
elseif bag == nil and slot then
    print("Item is equipped in slot " .. slot)
else
    print("Item not found")
end

-- Find item by name (uses cache for performance after first lookup)
local bag, slot = FindPlayerItemSlot("Hearthstone")
if slot then
    if bag == nil then
        print("Hearthstone is equipped in slot " .. slot)
    elseif bag == 0 then
        print("Hearthstone is in inventory pack slot " .. slot .. " (1-16)")
    elseif bag == -1 then
        print("Hearthstone is in bank slot " .. slot .. " (1-24)")
    elseif bag == -2 then
        print("Hearthstone is in keyring slot " .. slot .. " (1-16)")
    else
        print("Hearthstone is in bag " .. bag .. " slot " .. slot)
    end
end
```

#### UseItemIdOrName(itemIdOrName, [target])
Uses the first matching item found in the player's inventory (including equipped items) by item ID or name.

**Parameters:**
- `itemIdOrName` (number|string): Item ID or item name (case-insensitive)
- `target` (optional, string|number): Unit token (e.g. `"target"`, `"player"`) or GUID
  - If omitted, uses `LockedTargetGuid` if set; otherwise falls back to the active player GUID.

**Returns:**
- `1` if the item was found and `CGItem_C::Use(...)` returned non-zero
- `0` if the item was not found or use failed

**Examples:**
```lua
-- Use Hearthstone
UseItemIdOrName("Hearthstone")

-- Use a healing potion on yourself (if the item requires a target)
UseItemIdOrName(13446, "player")
```

#### GetEquippedItems(unitToken)
Returns a table reference containing all equipped items for the specified unit.

**Parameters:**
- `unitToken` (string): Can be a standard unit token ("player", "target", "pet", etc.) or a GUID string

**Returns:**
- A Lua table reference with equipment slot indices as keys (0-18) and item info tables as values
- Returns nil if the unit cannot be found or inspected

For the player, item info includes:
- `itemId`: The item's ID
- `stackCount`: Number of items in the stack
- `duration`: Item duration in milliseconds
- `spellCharges`: Table of spell charges (indices 1-5)
- `flags`: Item flags
- `permanentEnchantId`: Permanent enchantment ID
- `tempEnchantId`: Temporary enchantment ID
- `tempEnchantmentTimeLeftMs`: Time remaining on temp enchant in milliseconds
- `tempEnchantmentCharges`: Charges remaining on temp enchant
- `durability`: Current durability
- `maxDurability`: Maximum durability

For other inspected units (limited data):
- `itemId`: The item's ID
- `permanentEnchantId`: Permanent enchantment ID
- `tempEnchantId`: Temporary enchantment ID

**Examples:**
```lua
-- Get all equipped items for your target
local items = GetEquippedItems("target")
if items then
    for slot, itemInfo in pairs(items) do
        print("Slot " .. slot .. ": Item ID " .. itemInfo.itemId)
        if itemInfo.permanentEnchantId and itemInfo.permanentEnchantId > 0 then
            print("  Permanent enchant: " .. itemInfo.permanentEnchantId)
        end
    end
end

-- Check player's weapon durability
local items = GetEquippedItems("player")
if items and items[15] then -- slot 15 is main hand
    local weapon = items[15]
    print("Weapon durability: " .. weapon.durability .. "/" .. weapon.maxDurability)
end
```

#### GetEquippedItem(unitToken, slot)
Returns item info for a specific equipment slot on the specified unit.

**Parameters:**
- `unitToken` (string): Can be a standard unit token ("player", "target", "pet", etc.) or a GUID string
- `slot` (number): Equipment slot number (0-18)
  - 1 = Head, 2 = Neck, 3 = Shoulder, 4 = Shirt, 5 = Chest
  - 6 = Waist, 7 = Legs, 8 = Feet, 9 = Wrist, 10 = Hands
  - 11 = Finger 1, 12 = Finger 2, 13 = Trinket 1, 14 = Trinket 2
  - 15 = Back, 16 = Main Hand, 17 = Off Hand, 18 = Ranged, 19 = Tabard

**Returns:**
- A Lua table reference containing the item info (same fields as GetEquippedItems)
- Returns nil if the slot is empty, unit cannot be found, or unit cannot be inspected

**Examples:**
```lua
-- Check target's main hand weapon
local weapon = GetEquippedItem("target", 16)
if weapon then
    print("Target has weapon: " .. weapon.itemId)
else
    print("Target has no main hand weapon")
end

-- Check your own helmet
local helm = GetEquippedItem("player", 1)
if helm and helm.durability then
    local durabilityPercent = (helm.durability / helm.maxDurability) * 100
    print("Helmet durability: " .. string.format("%.1f%%", durabilityPercent))
end
```

#### GetBagItems()
Returns a nested table reference containing all items in all bags (including bank if open).

**Returns:**
- A Lua table reference with bag indices as keys and bag contents as values
- Each bag contains **1-indexed** slot numbers as keys and item info tables as values
- Bag indices:
  - 0 = Inventory pack (16 slots)
  - 1-4 = Regular bags
  - -1 = Bank item slots (24 slots, only if bank is open)
  - 5-9 = Bank bags (only if bank is open)
  - -2 = Keyring

Item info table fields (same as GetEquippedItems for player):
- `itemId`, `stackCount`, `duration`, `spellCharges`, `flags`
- `permanentEnchantId`, `tempEnchantId`, `tempEnchantmentTimeLeftMs`, `tempEnchantmentCharges`
- `durability`, `maxDurability`

**Examples:**
```lua
-- Get all items in all bags
local allItems = GetBagItems()
for bagIndex, bagContents in pairs(allItems) do
    print("Bag " .. bagIndex .. ":")
    for slot, itemInfo in pairs(bagContents) do
        print("  Slot " .. slot .. ": " .. itemInfo.itemId .. " (x" .. itemInfo.stackCount .. ")")
    end
end

-- Count total number of a specific item
local function CountItem(itemId)
    local total = 0
    local allItems = GetBagItems()
    for bagIndex, bagContents in pairs(allItems) do
        for slot, itemInfo in pairs(bagContents) do
            if itemInfo.itemId == itemId then
                total = total + itemInfo.stackCount
            end
        end
    end
    return total
end

local soulShardCount = CountItem(6265)
print("Soul Shards: " .. soulShardCount)
```

#### GetBagItem(bagIndex, slot)
Returns item info for a specific slot in a specific bag.

**Parameters:**
- `bagIndex` (number): The bag to check
  - 0 = Inventory pack
  - 1-4 = Regular bags
  - -1 = Bank item slots or buyback slots
  - 5-9 = Bank bags (requires bank to be open)
  - -2 = Keyring
- `slot` (number): **1-indexed** slot number within the bag

**Returns:**
- A Lua table reference containing the item info (same fields as GetBagItems)
- Returns nil if the slot is empty or invalid

**Examples:**
```lua
-- Get item in first slot of first bag
local item = GetBagItem(1, 1)
if item then
    print("Item ID: " .. item.itemId)
    print("Stack count: " .. item.stackCount)
else
    print("Slot is empty")
end

-- Check durability of an item in inventory pack
local item = GetBagItem(0, 1)
if item and item.durability then
    print("Durability: " .. item.durability .. "/" .. item.maxDurability)
end

-- Check if a specific bank slot has an item (bank must be open)
local bankItem = GetBagItem(-1, 1)
if bankItem then
    print("Bank slot 1 contains: " .. bankItem.itemId)
end
```

#### GetSpellRec(spellId, [copy])
Returns a Lua table reference containing all fields for the spell's `SpellRec` record (including localized `name` and `rank`). Returns nil if the spell cannot be found.

**Optional parameter:** Pass `1` for `copy` to get an independent table copy instead of a reusable reference.

Full field name lists are in [`DBC_FIELDS.md`](DBC_FIELDS.md).

#### GetSpellRecField(spellId, fieldName, [copy])
Fast lookup for a single field on a spell. Returns the requested field value; returns nil if the spell is not found; raises a Lua error if the field name is invalid.

**Optional parameter:** Pass `1` for `copy` to get an independent table copy (for array fields only).

Full field name lists are in [`DBC_FIELDS.md`](DBC_FIELDS.md).

**Examples:**
```lua
-- Get spell name
local name = GetSpellRecField(116, "name")
print(name) -- "Frostbolt"

-- Get spell rank
local rank = GetSpellRecField(116, "rank")
print(rank) -- "Rank 1"

-- Get spell cast time in milliseconds
local castTime = GetSpellRecField(133, "castTime")
print("Fireball cast time: " .. (castTime / 1000) .. " seconds") -- 3.5 seconds

-- Get spell range (max range in yards * 10, so divide by 10)
local maxRange = GetSpellRecField(116, "rangeMax")
print("Frostbolt max range: " .. (maxRange / 10) .. " yards") -- 30 yards

-- Get spell mana cost
local manaCost = GetSpellRecField(116, "manaCost")
print("Mana cost: " .. manaCost)

-- Get spell school (0=Physical, 1=Holy, 2=Fire, 3=Nature, 4=Frost, 5=Shadow, 6=Arcane)
local school = GetSpellRecField(116, "school")
print("School: " .. school) -- 4 (Frost)

-- Get spell icon ID
local spellIconID = GetSpellRecField(116, "spellIconID")
print("Icon ID: " .. spellIconID)
```

#### GetSpellModifiers(spellId, modifierType)
Returns the current spell modifiers applied to a spell for the player. This includes buffs, talents, and other effects that modify spell behavior.

**Parameters:**
- `spellId` (number): The spell ID to check
- `modifierType` (number): The type of modifier to check (see list below)

**Returns:**
- 1st param (number): Flat modification value (e.g., +50 damage)
- 2nd param (number): Percent modification value (e.g., 10 for +10%)
- 3rd param (number): Return value from the function (whether there was any percent or flat modifier)

**Modifier Types:**
- 0 = DAMAGE
- 1 = DURATION
- 2 = THREAT
- 3 = ATTACK_POWER
- 4 = CHARGES
- 5 = RANGE
- 6 = RADIUS
- 7 = CRITICAL_CHANCE
- 8 = ALL_EFFECTS
- 9 = NOT_LOSE_CASTING_TIME
- 10 = CASTING_TIME
- 11 = COOLDOWN
- 12 = SPEED
- 14 = COST
- 15 = CRIT_DAMAGE_BONUS
- 16 = RESIST_MISS_CHANCE
- 17 = JUMP_TARGETS
- 18 = CHANCE_OF_SUCCESS
- 19 = ACTIVATION_TIME
- 20 = EFFECT_PAST_FIRST
- 21 = CASTING_TIME_OLD
- 22 = DOT
- 23 = HASTE
- 24 = SPELL_BONUS_DAMAGE
- 27 = MULTIPLE_VALUE
- 28 = RESIST_DISPEL_CHANCE

**Example:**
```lua
-- Check damage modifiers on Frostbolt (spell ID 116)
local flatMod, percentMod, ret = GetSpellModifiers(116, 0)
print("Flat damage bonus: " .. flatMod)
print("Percent damage bonus: " .. percentMod .. "%")
```

#### GetUnitData(unitToken, [copy])
Returns a Lua table reference containing all unit fields for the specified unit. This provides access to low-level unit data like health, mana, stats, auras, resistances, and more.

**Parameters:**
- `unitToken` (string): Can be a standard unit token ("player", "target", "pet", "mouseover", etc.) or a GUID string (e.g., "0xF5300000000000A5")
- `copy` (number, optional): Pass `1` to get an independent table copy instead of a reusable reference

**Returns:**
- A Lua table reference containing all unit fields, or nil if the unit cannot be found

Full field name lists are in [`UNIT_FIELDS.md`](UNIT_FIELDS.md).

**Example:**
```lua
-- Get all unit data for your current target
local data = GetUnitData("target")
if data then
    print("Target health: " .. data.health .. "/" .. data.maxHealth)
    print("Target level: " .. data.level)
    print("Target display ID: " .. data.displayId)
end

-- Using a GUID
local data = GetUnitData("0xF5300000000000A5")
```

#### GetUnitField(unitToken, fieldName, [copy])
Fast lookup for a single field on a unit. More efficient than GetUnitData when you only need one specific field.

**Parameters:**
- `unitToken` (string): Can be a standard unit token ("player", "target", "pet", "mouseover", etc.) or a GUID string
- `fieldName` (string): The name of the field to retrieve
- `copy` (number, optional): Pass `1` to get an independent table copy (for array fields only)

**Returns:**
- The requested field value; returns nil if the unit is not found; raises a Lua error if the field name is invalid
- For array fields (like "aura", "resistances"), returns a Lua table with numeric indices

Full field name lists are in [`UNIT_FIELDS.md`](UNIT_FIELDS.md).

**Examples:**
```lua
-- Get target's current health
local health = GetUnitField("target", "health")
print("Target health: " .. health)

-- Get player's current mana (power1)
local mana = GetUnitField("player", "power1")
print("Player mana: " .. mana)

-- Get all auras on target (returns a table)
local auras = GetUnitField("target", "aura")
for i, auraId in ipairs(auras) do
    print("Aura " .. i .. ": " .. auraId)
end

-- Get all resistances (returns a table)
local resistances = GetUnitField("player", "resistances")
-- resistances[1] = armor, [2] = holy, [3] = fire, [4] = nature, [5] = frost, [6] = shadow, [7] = arcane
```

#### QueueSpellByName(spellName)
Will force queue a spell regardless of the appropriate queue window.  If no spell is currently being cast it will be cast immediately.
For example can make a macro with
```
/run QueueSpellByName("Frostbolt");QueueSpellByName("Frostbolt")
```
to cast 2 frostbolts in a row.  Currently, can only queue 1 GCD spell at a time and 5 non gcd spells.  This means you can't do 3 frostbolts in a row with one macro.

#### CastSpellByNameNoQueue(spellName)
Will force a spell cast to never queue even if your settings would normally queue.  Can be used to fix addons that don't work with queued spells.

#### QueueScript(script, [priority])
Queues any arbitrary script using the same logic as a regular spell using NP_SpellQueueWindowMs as the window.  If no spell is being cast and you are not on the gcd the script will be run immediately.

Priority is optional and defaults to 1.
Priority 1 means the script will run before any other queued spells.
Priority 2 means the script will run after any queued non gcd spells but before any queued normal spells.
Priority 3 means the script will run after any type of queued spells.

Convert slash commands from other addons like `/equip` to their function form `SlashCmdList.EQUIP` to use them inside QueueScript.

For example, you can equip a libram before casting a queued heal using
```
/run QueueScript('SlashCmdList.EQUIP("Libram of +heal")')
```

#### IsSpellInRange(spellName, [target]) or IsSpellInRange(spellId, [target])
Takes a spell name or spell id and an optional target.  Target can the usual UNIT tokens like "player", "target", "mouseover", etc or a unit guid.

If using spell name it must be a spell you have in your spellbook.  If using spell id it can be any spell id.

Returns 1 if the spell is in range, 0 if not in range, and -1 if the spell is not valid for this check (must be TARGET_UNIT_PET, TARGET_UNIT_TARGET_ENEMY, TARGET_UNIT_TARGET_ALLY, TARGET_UNIT_TARGET_ANY).
This is because this uses the same underlying function as `IsActionInRange` which returns 1 for spells that are not single target which can be misleading.

Examples:
```
/run local result=IsSpellInRange("Frostbolt"); if result == 1 then print("In range") else if result == 0 then print("Out of range") else print("Not single target") end
```

#### IsSpellUsable(spellName) or IsSpellUsable(spellId)
Takes a spell name or spell id.

Usable does not equal castable.  This is most often used to check if a reactive spell is usable.

If using spell name it must be a spell you have in your spellbook.  If using spell id it can be any spell id.

Returns:

1st param: 1 if the spell is usable, 0 if not usable.
2nd param: Always 0 if spell is not usable for a different reason other than mana.  1 if out of mana, 0 if not out of mana.

Examples:
```
/run local result=IsSpellUsable("Frostbolt"); if result == 1 then print("Frostbolt usable") else print("Frostbolt not usable") end
```

#### GetCurrentCastingInfo()
Returns:

1st param: Casting spell id or 0
2nd param: Visual spell id or 0.  This won't always get cleared after a spell finishes.
3rd param: Auto repeating spell id or 0.
4th param: 1 if casting spell with a cast time, 0 if not.
5th param: 1 if channeling, 0 if not.
6th param: 1 if on swing spell is pending, 0 if not.
7th param: 1 if auto attacking, 0 if not.

For normal spells these will be the same.  For some spells like auto-repeating and channeling spells only the visual spell id will be set.

Examples:
```
/run local castId,visId,autoId,casting,channeling,onswing,autoattack=GetCurrentCastingInfo();print(castId);print(visId);print(autoId);print(casting);print(channeling);print(onswing);print(autoattack);
```

#### GetCastInfo()
Returns detailed information about the currently active cast or channel. Returns nil if there is no active cast or channel.
GetCurrentCastingInfo was made very early on and doesn't provide enough information for many use cases, but still has some uses and is available for backwards compatibility.

**Returns:**
A Lua table reference with the following fields, or nil if no cast is active:

- `castId` (number): Unique identifier for this cast
- `spellId` (number): The spell ID being cast
- `guid` (number): Target GUID (0 if no explicit target)
- `castType` (number): Type of cast - 0=NORMAL, 3=CHANNEL, 4=TARGETING
- `castStartS` (number): When the cast started in WoW time (seconds with decimals, e.g., 1234567.890)
- `castEndS` (number): When the cast will end in WoW time (seconds with decimals)
- `castRemainingMs` (number): Milliseconds remaining until cast ends
- `castDurationMs` (number): Total cast duration in milliseconds
- `gcdEndS` (number): When the GCD will end in WoW time (seconds with decimals)
- `gcdRemainingMs` (number): Milliseconds remaining until GCD expires

**Notes:**
- Time fields ending in `S` (castStartS, castEndS, gcdEndS) are absolute timestamps in **seconds** with decimal precision to match GetTime() in Lua
- Duration and remaining fields ending in `Ms` (castRemainingMs, castDurationMs, gcdRemainingMs) are in **milliseconds** for precision
- Returns nil if there is no active cast (castSpellId is 0) and no active channel (channelSpellId is 0)

**Examples:**
```lua
-- Check current cast information
local info = GetCastInfo()
if info then
    print("Casting spell: " .. info.spellId)
    print("Cast ends at: " .. info.castEndS)
    print("Time remaining: " .. info.castRemainingMs .. "ms")
    print("GCD ends at: " .. info.gcdEndS)
    print("GCD remaining: " .. info.gcdRemainingMs .. "ms")
else
    print("No active cast")
end

-- Check if you can cast another spell (GCD check)
local info = GetCastInfo()
if not info or info.gcdRemainingMs == 0 then
    print("Ready to cast!")
else
    print("On GCD for " .. info.gcdRemainingMs .. "ms more")
end

-- Monitor cast progress
local info = GetCastInfo()
if info and info.castDurationMs > 0 then
    local progress = ((info.castDurationMs - info.castRemainingMs) / info.castDurationMs) * 100
    print("Cast progress: " .. string.format("%.1f%%", progress))
end
```

#### GetSpellIdCooldown(spellId)
Returns detailed cooldown information for a spell from the spell history. This provides precise timing data for individual spell cooldowns, category cooldowns, and GCD.

**Parameters:**
- `spellId` (number): The spell ID to check

**Returns:**
A Lua table reference with the following fields:

- `isOnCooldown` (number): 1 if any cooldown is active, 0 otherwise
- `cooldownRemainingMs` (number): Maximum remaining time across all cooldown types in milliseconds
- `itemId` (number): Item ID tied to the cooldown (0 if none)
- `itemHasActiveSpell` (number): 1 if the item has an on-use spell, 0 otherwise
- `itemActiveSpellId` (number): Spell ID of the active item spell (0 if none)

**Individual Spell Cooldown:**
- `individualStartS` (number): When the individual spell cooldown started (seconds, WoW time)
- `individualDurationMs` (number): Total duration of the individual spell cooldown in milliseconds
- `individualRemainingMs` (number): Milliseconds remaining on the individual spell cooldown
- `isOnIndividualCooldown` (number): 1 if the spell-specific cooldown is active, 0 otherwise

**Category Cooldown:**
- `categoryId` (number): The cooldown category ID (0 if no category cooldown)
- `categoryStartS` (number): When the category cooldown started (seconds, WoW time)
- `categoryDurationMs` (number): Total duration of the category cooldown in milliseconds
- `categoryRemainingMs` (number): Milliseconds remaining on the category cooldown
- `isOnCategoryCooldown` (number): 1 if the category cooldown is active, 0 otherwise

**GCD (Global Cooldown):**
- `gcdCategoryId` (number): The GCD category ID (typically 133 for most spells)
- `gcdCategoryStartS` (number): When the GCD started (seconds, WoW time)
- `gcdCategoryDurationMs` (number): Total GCD duration in milliseconds (typically 1500ms)
- `gcdCategoryRemainingMs` (number): Milliseconds remaining on the GCD
- `isOnGcdCategoryCooldown` (number): 1 if the GCD is active, 0 otherwise

**Notes:**
- Time fields ending in `S` are absolute timestamps in **seconds** to match GetTime() in Lua
- Fields ending in `Ms` are in **milliseconds** for precision
- The spell must have been cast at least once for accurate data to be available
- `cooldownRemainingMs` is the maximum of all three cooldown types

**Example:**
```lua
-- Check if Frostbolt is ready to cast
local cd = GetSpellIdCooldown(116) -- Frostbolt
if cd.isOnCooldown == 0 then
    print("Frostbolt is ready!")
else
    print("Frostbolt on cooldown for " .. cd.cooldownRemainingMs .. "ms")
    if cd.isOnGcdCategoryCooldown == 1 then
        print("  GCD: " .. cd.gcdCategoryRemainingMs .. "ms remaining")
    end
    if cd.isOnIndividualCooldown == 1 then
        print("  Spell CD: " .. cd.individualRemainingMs .. "ms remaining")
    end
    if cd.isOnCategoryCooldown == 1 then
        print("  Category CD: " .. cd.categoryRemainingMs .. "ms remaining")
    end
end
```

#### GetItemIdCooldown(itemId)
Returns detailed cooldown information for an item from the spell history. Works similarly to GetSpellIdCooldown but for items.

**Parameters:**
- `itemId` (number): The item ID to check

**Returns:**
A Lua table reference with the same structure as GetSpellIdCooldown (see above).

**Notes:**
- Returns the longest cooldown among all spells associated with the item
- If the item has multiple on-use effects, returns information for the one with the longest remaining cooldown
- Item cooldowns are tracked through their associated spell entries in the spell history

**Example:**
```lua
-- Check if a trinket is ready
local cd = GetItemIdCooldown(12345) -- Replace with your trinket ID
if cd.isOnCooldown == 0 then
    print("Trinket is ready to use!")
else
    print("Trinket on cooldown for " .. cd.cooldownRemainingMs .. "ms")
end
```

#### GetTrinkets([copy])
Returns a table of trinkets from equipped trinket slots and carried bags.

**Parameters:**
- `[copy]` (number|boolean, optional): Pass `1` (or any truthy value) to force creation of a fresh Lua table. By default the function reuses an internal table and entry tables for performance.

**Returns:**
A Lua table where each entry contains:
- `itemId` (number)
- `trinketName` (string, `"Unknown"` if no name available)
- `texture` (string): Texture name for the item icon
- `bagIndex` (number|nil): `nil` when equipped; `0` for backpack; `1-4` for equipped bags
- `slotIndex` (number): Lua 1-based slot within the container (or 1/2 for equipped trinket slots)

**Notes:**
- Scans only equipped trinket slots and bags 0-4 (backpack + equipped bags). Does not scan bank or keyring.
- Reuses cached Lua tables unless `copyTable` is truthy; prefer copies if you will mutate the returned tables.
-
#### GetTrinketCooldown(slot|itemIdOrName)
Returns cooldown information for the equipped trinket(s) in slots 13 or 14. Accepts slot shortcuts or item identifiers.

**Parameters:**
- `slot|itemIdOrName` (number|string):
  - `1` or `13` => first trinket slot
  - `2` or `14` => second trinket slot
  - Any other number => treat as item ID to match against trinket slots
  - String => item name (case-insensitive) to match against trinket slots

**Returns:**
- If no matching trinket is equipped in slots 13/14: returns `-1`
- Otherwise: a cooldown detail table with the same structure as `GetSpellIdCooldown` / `GetItemIdCooldown`

**Example:**
```lua
-- Get cooldown for first trinket slot
local cd = GetTrinketCooldown(1)
if cd ~= -1 and cd.isOnCooldown == 0 then
    print("Trinket ready")
end

-- Check by name
local cd = GetTrinketCooldown("Royal Seal of Eldre'Thalas")
if cd ~= -1 then
    print("Remaining: " .. cd.cooldownRemainingMs .. "ms")
end
```

#### UseTrinket(slot|itemIdOrName, [target])
Uses a trinket from the equipped trinket slots (13 and 14 only).

**Parameters:**
- `slot|itemIdOrName` (number|string):
  - `1` or `13` => use first trinket slot
  - `2` or `14` => use second trinket slot
  - Any other number => treat as item ID to find in trinket slots
  - String => item name (case-insensitive) to find in trinket slots
- `target` (optional, string|number): Unit token or GUID. If omitted, uses `LockedTargetGuid` if set; otherwise falls back to active player GUID.

**Returns:**
- `1` if the trinket was found and `CGItem_C::Use(...)` returned non-zero
- `0` if the trinket was found but use returned zero
- `-1` if no matching trinket was found in slots 13/14

**Examples:**
```lua
-- Use first trinket slot
UseTrinket(1)
-- Use second trinket slot on current target
UseTrinket(2, "target")
-- Use by item id if present in either trinket slot
UseTrinket(18406)
-- Use by name
UseTrinket("Royal Seal of Eldre'Thalas")
```

#### GetSpellIdForName(spellName)
Returns:

1st param: the max rank spell id for a spell name if it exists in your spellbook.  Returns 0 if the spell is not in your spellbook.

Examples:
```
/run local spellId=GetSpellIdForName("Frostbolt");print(spellId)
/run local spellId=GetSpellIdForName("Frostbolt(Rank 1)");print(spellId)
```

#### GetSpellNameAndRankForId(id)
Returns:

1st param: the spell name for a spell id
2nd param: the spell rank for a spell id as a string such as "Rank 1"

Examples:
```
/run local spellName,spellRank=GetSpellNameAndRankForId(116);print(spellName);print(spellRank)
prints "Frostbolt" and "Rank 1"
```

#### GetSpellSlotTypeIdForName(spellName)
Returns:

1st param: the 1 indexed (lua calls expect this) spell slot number for a spell name if it exists in your spellbook.  Returns 0 if the spell is not in your spellbook.
2nd param: the book type of the spell, either "spell", "pet" or "unknown".
3rd param: the spell id of the spell.  Returns 0 if the spell is not in your spellbook.

Examples:
```
/run local slot, bookType, spellId=GetSpellSlotTypeIdForName("Frostbolt");print(slot);print(bookType);print(spellId)
```

#### GetNampowerVersion()
Returns the current version of Nampower split into major, minor and patch numbers.

So if version was v2.8.6 it would return 2, 8, 6 as integers.

Examples:
```
/run local major, minor, patch=GetNampowerVersion();print(major);print(minor);print(patch)
```

The previous version of this `GetSpellSlotAndTypeForName` was removed as it was returning a 0 indexed slot number which was confusing to use in lua.

#### GetItemLevel(itemId)
Returns the item level of an item.  Returns an error if the item id is invalid.

Examples:
```
/run local itemLevel=GetItemLevel(22589);print(itemLevel)
should print 90 for atiesh
```

#### ChannelStopCastingNextTick()
Will stop channeling early on the next tick if you have queue channeling spells enabled and try to cast a spell before the next tick (didn't know how to cancel channels without casting another spell).  Uses your ChannelLatencyReductionPercentage to determine when to stop the channel.

---

### Utility Functions

#### DisenchantAll(itemIdOrName, [includeSoulbound]) or DisenchantAll(quality, [includeSoulbound])
Automatically disenchants items in your inventory. Can disenchant a specific item by ID/name, or all weapons and armor of a specified quality.

**⚠️ WARNING ⚠️**
**THIS FUNCTION WILL AUTOMATICALLY DISENCHANT ITEMS WITHOUT CONFIRMATION!**
- **Use at your own risk** - there is no undo for disenchanting
- Only disenchants items from **player inventory bags (0-4)** - does NOT touch bank items
- **Quest items are ALWAYS protected** regardless of settings
- **Soulbound items are protected by default** (can be overridden with optional parameter)
- Make sure you have the Disenchant spell and the items are disenchantable before using
- **Always double-check your bags** before running this command

**Parameters:**

**Mode 1: Disenchant by Item ID or Name**
- `itemIdOrName` (number|string): Item ID (number) or item name (string)
  - Disenchants all copies of the specified item found in your bags
  - Works on any disenchantable item type (weapons, armor, etc.)
- `includeSoulbound` (number, optional): Pass any non-zero value (e.g., `1`) to include soulbound items (defaults to `0`)

**Mode 2: Disenchant by Quality** *(weapons and armor only)*
- `quality` (string): Must be either:
  - `"greens"` - Disenchants all uncommon (green) quality weapons and armor
  - `"blues"` - Disenchants all rare (blue) quality weapons and armor
  - Only affects **weapons** (class 2) and **armor** (class 4)
- `includeSoulbound` (number, optional): Pass any non-zero value (e.g., `1`) to include soulbound items (defaults to `0`)

**Returns:**
- `1` if the first disenchant succeeded
- `0` if no matching items were found or the disenchant failed

**Behavior:**
- Searches player inventory bags (0-4) only - **bank items are protected**
- Finds the first matching item in your inventory
- Casts Disenchant spell on that item
- Automatically continues disenchanting matching items every 4 seconds
- Stops when no more matching items are found or an error occurs

**Examples:**
```lua
-- Disenchant all green weapons and armor in your bags (excluding soulbound)
DisenchantAll("greens")

-- Disenchant all blue weapons and armor including soulbound items
DisenchantAll("blues", 1)

-- Disenchant a specific item by ID (excluding soulbound)
DisenchantAll(12345)

-- Disenchant a specific item by name including soulbound items
DisenchantAll("Glowing Brightwood Staff", 1)
```

**Important Notes:**
- The function runs continuously until all matching items are disenchanted
- Items must be in your inventory bags (0-4), not in bank, keyring, or equipped
- When using quality mode ("greens"/"blues"), only weapons and armor are affected
- When using item ID/name mode, any disenchantable item can be targeted
- Make sure you have enough bag space for the disenchanting materials
- The function will stop if you run out of matching items or if the disenchant spell fails
- **REVIEW YOUR BAGS CAREFULLY BEFORE USE** - disenchanting cannot be undone!

# Unit Fields Reference

This document lists all available unit fields that can be accessed via `GetUnitData()` and `GetUnitField()` functions.

## Overview

Unit fields provide low-level access to game data for any unit (player, target, pet, NPCs, etc.). These fields are part of the WoW 1.12 client's internal data structures.

## Usage

```lua
-- Get all fields at once
local data = GetUnitData("target")
if data then
    print("Health: " .. data.health)
end

-- Get a single field (more efficient)
local health = GetUnitField("target", "health")
```

## Simple Fields

These fields return a single value (number).

### Object References (UINT64)
These fields contain GUIDs (globally unique identifiers) for game objects:

- **charm** - GUID of the unit that has charmed this unit
- **summon** - GUID of the unit's current summon
- **charmedBy** - GUID of the unit that charmed this unit
- **summonedBy** - GUID of the unit that summoned this unit
- **createdBy** - GUID of the unit that created this unit
- **target** - GUID of the unit's current target
- **persuaded** - GUID of the unit being persuaded
- **channelObject** - GUID of the object being channeled (for channeling spells)

### Health and Power (UINT32)
- **health** - Current health points
- **power1** - Current mana (or energy/rage depending on class)
- **power2** - Current rage
- **power3** - Current focus (hunter pets)
- **power4** - Current energy (rogues, druids in cat/bear form)
- **power5** - Current happiness (hunter pets)
- **maxHealth** - Maximum health points
- **maxPower1** - Maximum mana
- **maxPower2** - Maximum rage
- **maxPower3** - Maximum focus
- **maxPower4** - Maximum energy
- **maxPower5** - Maximum happiness

### Basic Unit Info (UINT32)
- **level** - Unit's level
- **factionTemplate** - Unit's faction template ID
- **flags** - Unit flags (combat, dead, mounted, etc.)
- **dynamicFlags** - Dynamic unit flags (lootable, tapped, etc.)
- **auraState** - Aura state flags (reactive abilities like Revenge, Overpower)
- **npcFlags** - NPC flags (vendor, trainer, quest giver, etc.)
- **npcEmoteState** - Current emote state ID

### Display and Appearance (UINT32)
- **displayId** - Current display model ID
- **nativeDisplayId** - Original/native display model ID
- **mountDisplayId** - Mount display model ID (if mounted)

### Combat Stats (UINT32)
- **baseAttackTime** - Base main-hand attack time in milliseconds
- **offhandAttackTime** - Off-hand attack time in milliseconds
- **rangedAttackTime** - Ranged attack time in milliseconds

### Combat Stats (FLOAT)
- **boundingRadius** - Unit's bounding radius for collision
- **combatReach** - Unit's combat reach distance
- **minDamage** - Minimum main-hand damage
- **maxDamage** - Maximum main-hand damage
- **minOffhandDamage** - Minimum off-hand damage
- **maxOffhandDamage** - Maximum off-hand damage
- **minRangedDamage** - Minimum ranged damage
- **maxRangedDamage** - Maximum ranged damage

### Pet Info (UINT32)
- **petNumber** - Pet's number identifier
- **petNameTimestamp** - Timestamp of pet name
- **petExperience** - Pet's current experience
- **petNextLevelExp** - Experience needed for pet's next level

### Spell/Channel Info (UINT32)
- **channelSpell** - Spell ID of currently channeling spell
- **createdBySpell** - Spell ID that created this unit (for summons)

### Casting Speed (FLOAT)
- **modCastSpeed** - Cast speed modifier (1.0 = normal, <1.0 = faster, >1.0 = slower)

### Training (UINT32)
- **trainingPoints** - Available training points (for pets and talents)

### Base Stats (UINT32)
- **stat0** - Strength
- **stat1** - Agility
- **stat2** - Stamina
- **stat3** - Intellect
- **stat4** - Spirit
- **baseMana** - Base mana before modifiers
- **baseHealth** - Base health before modifiers

### Attack Power (UINT32)
- **attackPower** - Total melee attack power
- **attackPowerMods** - Attack power modifiers
- **rangedAttackPower** - Total ranged attack power
- **rangedAttackPowerMods** - Ranged attack power modifiers

### Attack Power Multipliers (FLOAT)
- **attackPowerMultiplier** - Melee attack power multiplier
- **rangedAttackPowerMultiplier** - Ranged attack power multiplier

### Packed Byte Fields (UINT32)
These are special fields that pack multiple values into a single 32-bit integer:

- **bytes0** - Contains race, class, gender, and power type
  - Byte 0: Race
  - Byte 1: Class
  - Byte 2: Gender
  - Byte 3: Power type

- **bytes1** - Contains stand state, pet talent points, vis flags, and anim tier
  - Byte 0: Stand state
  - Byte 1: Pet talent points
  - Byte 2: Vis flags
  - Byte 3: Anim tier

- **bytes2** - Contains sheath state, pvp flags, pet flags, and shape shift form
  - Byte 0: Sheath state
  - Byte 1: PvP flags
  - Byte 2: Pet flags
  - Byte 3: Shape shift form

## Array Fields

These fields return a Lua table with numeric indices (1-based).

### Visual Items (UINT32 arrays)
- **virtualItemDisplay** [3] - Display IDs for virtual items (weapon visuals, etc.)
- **virtualItemInfo** [6] - Additional virtual item information

### Auras/Buffs/Debuffs (UINT32 arrays)
- **aura** [48] - Array of aura (buff/debuff) spell IDs on the unit
  - Index 1-48 contains spell IDs (0 = no aura in that slot)

- **auraFlags** [6] - Bit flags for aura properties (positive, negative, cancelable, etc.)
  - Each UINT32 contains flags for 8 auras (4 bits per aura)

- **auraLevels** [48] - Aura caster levels (UINT8 per aura slot)

- **auraApplications** [48] - Aura stack counts (UINT8 per aura slot)

### Resistances (UINT32 arrays)
- **resistances** [7] - Resistance values for all schools
  - Index 1: Armor (physical resistance)
  - Index 2: Holy resistance
  - Index 3: Fire resistance
  - Index 4: Nature resistance
  - Index 5: Frost resistance
  - Index 6: Shadow resistance
  - Index 7: Arcane resistance

### Spell Power Modifiers (FLOAT arrays)
- **powerCostModifier** [7] - Flat mana cost modifications per school
  - Index 1-7: Physical, Holy, Fire, Nature, Frost, Shadow, Arcane

- **powerCostMultiplier** [7] - Percent mana cost modifications per school
  - Index 1-7: Physical, Holy, Fire, Nature, Frost, Shadow, Arcane

## Examples

### Health Monitoring
```lua
-- Monitor target health percentage
local health = GetUnitField("target", "health")
local maxHealth = GetUnitField("target", "maxHealth")
local healthPct = (health / maxHealth) * 100
print("Target health: " .. healthPct .. "%")
```

### Checking Auras
```lua
-- Check if target has a specific debuff
local auras = GetUnitField("target", "aura")
local CURSE_OF_AGONY = 980

for i, spellId in ipairs(auras) do
    if spellId == CURSE_OF_AGONY then
        print("Target has Curse of Agony!")
        break
    end
end
```

### Reading Resistances
```lua
-- Get all player resistances
local resistances = GetUnitField("player", "resistances")
print("Armor: " .. resistances[1])
print("Holy resistance: " .. resistances[2])
print("Fire resistance: " .. resistances[3])
print("Nature resistance: " .. resistances[4])
print("Frost resistance: " .. resistances[5])
print("Shadow resistance: " .. resistances[6])
print("Arcane resistance: " .. resistances[7])
```

### Checking Combat State
```lua
-- Check if unit is in combat (flags field bit check)
local flags = GetUnitField("target", "flags")
local UNIT_FLAG_IN_COMBAT = 0x00080000
local inCombat = bit.band(flags, UNIT_FLAG_IN_COMBAT) ~= 0
print("In combat: " .. tostring(inCombat))
```

### Monitoring Cast Speed
```lua
-- Check your current cast speed modifier
local modCastSpeed = GetUnitField("player", "modCastSpeed")
-- 1.0 = normal, 0.9 = 10% faster, 1.1 = 10% slower
print("Cast speed modifier: " .. modCastSpeed)
```

### Attack Power Info
```lua
-- Get your attack power
local ap = GetUnitField("player", "attackPower")
local apMods = GetUnitField("player", "attackPowerMods")
local apMult = GetUnitField("player", "attackPowerMultiplier")
print("Base AP: " .. ap)
print("AP Mods: " .. apMods)
print("AP Multiplier: " .. apMult)
```

### Pet Information
```lua
-- Check pet experience
if UnitExists("pet") then
    local petXP = GetUnitField("pet", "petExperience")
    local petNextXP = GetUnitField("pet", "petNextLevelExp")
    local progress = (petXP / petNextXP) * 100
    print("Pet XP: " .. progress .. "%")
end
```

## Notes

- GUID fields return numbers but represent 64-bit values. Lua handles these as doubles.
- Array indices are 1-based (Lua convention), not 0-based.
- Returns `nil` if the unit doesn't exist or the field cannot be read.
- Some fields may require specific game state to be meaningful (e.g., pet fields only work when you have a pet).
- Unit flags and other bit fields require bitwise operations to interpret properly.

## Related Functions

- `GetUnitData(unitToken)` - Get all fields at once
- `GetUnitField(unitToken, fieldName)` - Get a single field efficiently
- `GetSpellModifiers(spellId, modifierType)` - Get spell modifiers
- `GetItemStats(itemId)` - Get item data
- `GetSpellRec(spellId)` - Get spell data
